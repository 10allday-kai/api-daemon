extern crate cc;
extern crate prost_build;

use std::env;
use std::fs::{self, DirBuilder, File};
use std::io::Write;
use std::path::Path;

// Location of GIT submodule with C library
static C_LIBRARY_DIR: &'static str = "libsignal-protocol-c";

// Check if file1 is newer than file2
// If file2 doesn't exist, return true.

fn is_newer(path1: &str, path2: &str) -> bool {
    let file1 = File::open(path1);
    if file1.is_err() {
        return false;
    }
    let file2 = File::open(path2);
    if file2.is_err() {
        return true;
    }

    let meta1 = file1.unwrap().metadata().unwrap();
    let meta2 = file2.unwrap().metadata().unwrap();
    meta1.modified().unwrap() > meta2.modified().unwrap()
}

// TODO: unwrap less.
fn generate_mod(dir: &str) {
    // Look for all the *.rs file and subdirectories in this directory
    //  and add them to the local mod.rs
    let path = Path::new(dir);
    if !path.is_dir() {
        return;
    }
    let mut items = vec![];

    for entry in fs::read_dir(dir).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();
        if path.is_dir() {
            if let Some(p) = path.file_name() {
                items.push(p.to_str().unwrap().to_owned());
            }
        }

        if let Some(ext) = path.extension() {
            if ext == "rs" && !path.ends_with("mod.rs") {
                if let Some(p) = path.file_stem() {
                    items.push(p.to_str().unwrap().to_owned());
                }
            }
        }
    }

    let mut mod_file = File::create(path.join("mod.rs")).unwrap();
    for item in items {
        mod_file
            .write_fmt(format_args!("#[macro_use] pub mod {};\n", item))
            .unwrap();
    }
}

fn main() {
    let library_dir = format!(
        "{}/{}",
        env::var("CARGO_MANIFEST_DIR").unwrap(),
        C_LIBRARY_DIR
    );
    let build_dir = format!("{}/../cmake", env::var("OUT_DIR").unwrap());

    // Run C library build script
    let status = std::process::Command::new("./build.sh")
        .env("C_LIBRARY_DIR", library_dir)
        .env("C_BUILD_DIR", build_dir.clone())
        .status()
        .unwrap();
    assert!(
        status.code().unwrap() == 0,
        "Build script \"./build.sh\" exited with non-zero exit status!"
    );

    // Expose built library to cargo
    println!("cargo:rustc-link-lib=static=signal-protocol-c");
    println!("cargo:rustc-link-search=native={}/src", build_dir);

    // Build our helpers.
    cc::Build::new().file("helpers.c").compile("helpers");

    // Generate the ffi
    let status = std::process::Command::new("./bindgen.sh").status().unwrap();
    assert!(
        status.code().unwrap() == 0,
        "Build script \"./bindgen.sh\" exited with non-zero exit status!"
    );

    // Generate the protocol buffer bindings.
    println!("cargo:rerun-if-changed=src/libsignal.proto");

    let _ = DirBuilder::new().recursive(true).create("src/generated");

    if is_newer("src/libsignal.proto", "src/generated/libsignal_proto.rs") {
        prost_build::compile_protos(&["src/libsignal.proto"], &["src/"]).expect("prost generation");

        // Move the file generated by prost to src/generated/libsignal_proto.rs
        fs::copy(
            Path::new(&env::var("OUT_DIR").unwrap()).join("libsignal.rs"),
            "src/generated/libsignal_proto.rs",
        )
        .unwrap();
    }

    generate_mod("src/generated");

    println!("cargo:rerun-if-changed=custom-types.rs");
    println!("cargo:rerun-if-changed=bindgen.sh");
    println!("cargo:rerun-if-changed=wrapper.h");
    println!("cargo:rerun-if-changed=helpers.c");
}
